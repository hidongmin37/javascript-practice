<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      const housing = {
        toilet: 1,
        turnon() {
          console.log('turn on.. ');
        }
      };
      const apt = {
        color: 'red',
        rooms: 4
      };
      console.log(apt);
      apt.__proto__ = housing;
      console.log(apt);
      console.log(apt.turnon());

      const villa = {
        color: 'black',
        rooms: 3
      };

      villa.__proto__ = housing;

      const oneroom = {
        color: 'blue',
        rooms: 1
      };
      oneroom.__proto__ = housing;

      const rainbow = {
        name: '무지개 아파트',
        room: 5
      };

      rainbow.__proto__ = apt;
      console.log(rainbow.color);

      console.log(rainbow.toilet);
      console.log(rainbow.turnon());

      console.clear();
      //   for (let i in rainbow) {
      //     console.log(i);
      //   }
      //위와 같이 프로토타입 체인이 연결되어 있는(부모)의 멤버(속성,메서드)들이 다 나온다.
      // Object.keys() vs Object.values()
      //   console.log(Object.keys(rainbow));
      //   console.log(Object.values(rainbow));
      console.log(Object.entries(rainbow)); // 객체가 아닌 배열로 리턴해줌
      //[5] :if 조건문과 hasOwnProperty()메서드를 같이 사용.
      console.clear();
      for (let i in rainbow) {
        // console.log(i);
        if (rainbow.hasOwnProperty(i)) {
          console.log(i, '-->', rainbow[i]);
        } else {
          console.log(i, '-->', '');
        }
      }

      //이를 통해서 알 수 있듯이 -->hasOwnProperty()메서드는 해당 객체가 가지고 있는 속성에 대해서만 true를 반환.

      //앞서의 예제를 생성자 함수와 new연산자를 사용하는 예제로 바꿔보시오.
      // 생성자 함수
      console.clear();
      const Housing = function (name, color, rooms) {
        this.name = name;
        this.color = color;
        this.rooms = rooms;
      };
      // Housing 프로토타입 객체
      Housing.prototype.toilet = 1;
      Housing.prototype.turnon = function () {
        console.log('turn on');
      };

      // 객체 생성 --> new
      const aptObject = new Housing('apt', 'red', 4);
      console.log(aptObject.name);
      console.log(aptObject.color);
      console.log(aptObject.rooms);
      console.log(aptObject.toilet);
      aptObject.turnon();
      console.log('----------');
      const oneroomObject = new Housing('oneroom', 'white', 1);
      console.log(oneroomObject.name);
      console.log(oneroomObject.color);
      console.log(oneroomObject.rooms);
      console.log(oneroomObject.toilet);
      oneroomObject.turnon();

      const rainbowObject = new Housing('무지개 아파트', 'red', 3);
      console.log(rainbowObject.name);
      console.log(rainbowObject.color);
      console.log(rainbowObject.rooms);
      console.log(rainbowObject.toilet);
      rainbowObject.turnon();

      //   rainbowObject.prototype.name = '태양 아파트'; //이건 에러나고
      //   console.log(rainbowObject.name);

      rainbowObject.name = '태양 아파트'; //이렇게는 변경 가능함
      console.log(rainbowObject.name);

      // 수정이 저렇게 되어진다면, 외부에서 손쉽게 수정을 할 수 있다는 것인데 --> 수정이 안되게끔 하려면?
    </script>
  </head>
  <body></body>
</html>
